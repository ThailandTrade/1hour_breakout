<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>FX Charts — Replay TV</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{margin:0;padding:0;height:100%;width:100%;background:#fff;overflow:hidden;font:14px/1.4 system-ui,Segoe UI,Roboto,Inter}
    #chart{position:fixed;inset:0}
    #overlay{position:fixed;inset:0;pointer-events:none}

    .hud{
      position:fixed;top:12px;left:12px;display:flex;gap:10px;z-index:10;align-items:center;flex-wrap:wrap;
      background:rgba(255,255,255,.92);border:1px solid #e5e7eb;border-radius:12px;padding:8px;
      box-shadow:0 6px 18px rgba(0,0,0,.08)
    }
    label{font-size:13px;opacity:.7}
    select{appearance:none;background:#fff;border:1px solid #d1d5db;border-radius:10px;padding:6px 10px;cursor:pointer}
    .tfs{display:flex;gap:6px;flex-wrap:wrap;max-width:56vw}
    .btn{appearance:none;border:1px solid #d1d5db;background:#fff;color:#111;padding:6px 10px;border-radius:10px;cursor:pointer;white-space:nowrap}
    .btn:hover{background:#f9fafb}
    .btn.active{border-color:#6366f1;box-shadow:0 0 0 2px rgba(99,102,241,.25)}
    input[type="text"]{border:1px solid #d1d5db;border-radius:10px;padding:6px 10px;min-width:110px}

    /* Global Trend banner */
    .gt{
      display:inline-flex;align-items:center;gap:8px;
      padding:6px 10px;border-radius:999px;border:1px solid #e5e7eb;
      background:#fff;color:#374151;font-weight:600;white-space:nowrap
    }
    .gt .basis{font-weight:500;color:#6b7280}
    .gt-bull{color:#16a34a;background:rgba(22,163,74,.06);border-color:rgba(22,163,74,.25)}
    .gt-bear{color:#dc2626;background:rgba(220,38,38,.06);border-color:rgba(220,38,38,.25)}
    .gt-none{color:#6b7280;background:#f3f4f6}

    /* SL/TP controls */
    .stg{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .tag{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid #e5e7eb}
    .tag-sl{color:#dc2626;background:rgba(220,38,38,.06)}
    .tag-tp{color:#16a34a;background:rgba(22,163,74,.06)}
  </style>
  <script src="https://unpkg.com/lightweight-charts@5/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <div id="chart"></div>
  <canvas id="overlay"></canvas>

  <div class="hud">
    <label for="pair">Pair&nbsp;</label>
    <select id="pair"></select>
    <div class="tfs" id="tfs"></div>

    <!-- SL/TP controls (manual inputs) -->
    <div class="stg">
      <span class="tag tag-sl">SL</span>
      <input id="inpSL" type="text" inputmode="decimal" placeholder="SL price" />
      <button id="setSL" class="btn" title="Créer ligne SL">Set SL</button>
      <button id="clrSL" class="btn" title="Supprimer SL">Clear SL</button>

      <span class="tag tag-tp">TP</span>
      <input id="inpTP" type="text" inputmode="decimal" placeholder="TP price" />
      <button id="setTP" class="btn" title="Créer ligne TP">Set TP</button>
      <button id="clrTP" class="btn" title="Supprimer TP">Clear TP</button>
    </div>

    <!-- Global Trend pill -->
    <span id="globalTrend" class="gt gt-none">GLOBAL TREND: NO TREND</span>
  </div>

<script>
(function(){
  const { createChart, CandlestickSeries, LineSeries, HistogramSeries, CrosshairMode } = window.LightweightCharts;

  // --- helpers ---
  function timeLabel(tsSec){
    const d = new Date(tsSec * 1000); // UTC
    const wd = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][d.getUTCDay()];
    const mon = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][d.getUTCMonth()];
    const dd = String(d.getUTCDate()).padStart(2,'0');
    const yy = String(d.getUTCFullYear()%100).padStart(2,'0');
    const hh = String(d.getUTCHours()).padStart(2,'0');
    const mm = String(d.getUTCMinutes()).padStart(2,'0');
    return `${wd} ${dd} ${mon} '${yy} ${hh}:${mm}`;
  }

  function parsePriceFromInput(str){
    if (typeof str !== 'string') return NaN;
    const s = str.trim().replace(',', '.');
    const v = Number(s);
    return Number.isFinite(v) ? v : NaN;
  }

  // --- Session shading (UTC fixed hours) ---
  const SESSION_BANDS = [
    { name: 'TOKYO',    startH: 0,  endH: 9,  fill: 'rgba(59,130,246,0.08)',  stroke: 'rgba(59,130,246,0.35)'  }, // 00:00–09:00 UTC
    { name: 'LONDON',   startH: 7,  endH: 16, fill: 'rgba(16,185,129,0.08)',  stroke: 'rgba(16,185,129,0.35)' }, // 07:00–16:00 UTC
    { name: 'NEW YORK', startH: 12, endH: 21, fill: 'rgba(234,179,8,0.08)',   stroke: 'rgba(234,179,8,0.35)' }  // 12:00–21:00 UTC
  ];
  let showSessions = true;

  // --- chart setup ---
  const chartEl = document.getElementById('chart');
  const overlay = document.getElementById('overlay');
  const pairSel  = document.getElementById('pair');
  const tfsBox   = document.getElementById('tfs');
  const gtEl     = document.getElementById('globalTrend');

  const inpSL = document.getElementById('inpSL');
  const inpTP = document.getElementById('inpTP');
  const setSLBtn = document.getElementById('setSL');
  const clrSLBtn = document.getElementById('clrSL');
  const setTPBtn = document.getElementById('setTP');
  const clrTPBtn = document.getElementById('clrTP');

  const chart = createChart(chartEl, {
    layout:{ background:{type:'solid',color:'#fff'}, textColor:'#111' },
    grid:{ vertLines:{color:'#f1f5f9'}, horzLines:{color:'#f1f5f9'} },
    crosshair:{
      mode:CrosshairMode.Normal,
      vertLine:{ color:'#94a3b8', labelVisible:true },
      horzLine:{ color:'#94a3b8', labelVisible:true },
    },
    localization:{
      timeFormatter: (time) => {
        const ts = (typeof time === 'number')
          ? time
          : (time && typeof time === 'object' && typeof time.timestamp === 'number' ? time.timestamp : null);
        return ts ? timeLabel(ts) : '';
      },
    },
  });

  // --- current view state ---
  let ws = null;
  let reconnectTimer = null;

  let wantedPair = null;
  let wantedTf   = null; // UPPER
  let currentKey = null; // "PAIR|TF"

  // series & overlay state
  let candleSeries = null;
  let emaSeries    = null;
  let volumeSeries = null;
  let lineUpper    = null;
  let lineLower    = null;

  // AOIs: array of {tf,type,low,high,key}
  let currentAOIs  = [];

  // incremental tracking
  let lastBarTimeSec = null;

  // --- SL/TP state ---
  let slLine = null;
  let tpLine = null;
  let lastClose = null;        // last candle close (placeholder helper)
  let currentMinMove = 0.00001;

  function roundToStep(price){
    if (!Number.isFinite(price) || !Number.isFinite(currentMinMove) || currentMinMove <= 0) return price;
    return Math.round(price / currentMinMove) * currentMinMove;
  }
  function clearSL(){
    if (slLine && candleSeries){ try{ candleSeries.removePriceLine(slLine); }catch(e){} }
    slLine = null;
  }
  function clearTP(){
    if (tpLine && candleSeries){ try{ candleSeries.removePriceLine(tpLine); }catch(e){} }
    tpLine = null;
  }
  function setSL(price){
    if (!Number.isFinite(price) || !candleSeries) return;
    clearSL();
    slLine = candleSeries.createPriceLine({
      price: roundToStep(price), color:'#dc2626', lineWidth:2, lineStyle:2,
      axisLabelVisible:true, title:'SL'
    });
  }
  function setTP(price){
    if (!Number.isFinite(price) || !candleSeries) return;
    clearTP();
    tpLine = candleSeries.createPriceLine({
      price: roundToStep(price), color:'#16a34a', lineWidth:2, lineStyle:2,
      axisLabelVisible:true, title:'TP'
    });
  }

  // SL/TP buttons -> read inputs
  setSLBtn.onclick = ()=>{
    const p = parsePriceFromInput(inpSL.value);
    if (Number.isFinite(p)) setSL(p);
  };
  clrSLBtn.onclick = ()=> { clearSL(); };
  setTPBtn.onclick = ()=>{
    const p = parsePriceFromInput(inpTP.value);
    if (Number.isFinite(p)) setTP(p);
  };
  clrTPBtn.onclick = ()=> { clearTP(); };

  // Enter key triggers Set
  inpSL.addEventListener('keydown', e=>{ if(e.key==='Enter') setSLBtn.click(); });
  inpTP.addEventListener('keydown', e=>{ if(e.key==='Enter') setTPBtn.click(); });

  // --- overlay drawing (sessions + AOI) ---
  let rafActive = false;
  let lastRAFTime = 0;

  function getRightAxisWidthPx() {
    try {
      const api = chart.priceScale && chart.priceScale('right');
      if (api && typeof api.width === 'function') {
        const w = api.width();
        if (Number.isFinite(w) && w > 0) return w;
      }
    } catch(_) {}
    return 64; // fallback
  }

  // NEW: HUD bounding box to avoid label overlap
  function getHudBoxOnCanvas() {
    const hud = document.querySelector('.hud');
    if (!hud) return null;
    const hudRect   = hud.getBoundingClientRect();
    const chartRect = chartEl.getBoundingClientRect();
    return {
      x: Math.max(0, hudRect.left - chartRect.left),
      y: Math.max(0, hudRect.top  - chartRect.top),
      w: Math.min(chartRect.width,  hudRect.right - hudRect.left),
      h: Math.min(chartRect.height, hudRect.bottom - hudRect.top),
    };
  }

  // UPDATED: sessions visible incl. current session, labels avoid HUD
function drawSessions() {
  if (!showSessions || !candleSeries) return;

  const ctx = overlay.getContext('2d');
  const DPR = window.devicePixelRatio || 1;

  ctx.save();
  ctx.scale(DPR, DPR);

  const tsApi = chart.timeScale();
  const range = tsApi.getVisibleRange();
  if (!range || typeof range.from !== 'number' || typeof range.to !== 'number') {
    ctx.restore();
    return;
  }

  const visibleFrom = range.from;
  const visibleTo   = range.to;
  const fullWidthCss = overlay.width / DPR;
  const axisRightW   = (function getRightAxisWidthPx(){
    try { const w = chart.priceScale('right')?.width?.(); if (Number.isFinite(w) && w>0) return w; } catch(_) {}
    return 64;
  })();
  const rightLimitX  = Math.max(0, fullWidthCss - axisRightW);
  const H            = overlay.height / DPR;

  // Calcul du décalage vertical sous la HUD
  const hud = document.querySelector('.hud');
  let topOffset = 8;
  if (hud) {
    const hudRect = hud.getBoundingClientRect();
    const chartRect = chartEl.getBoundingClientRect();
    topOffset = Math.max(8, hudRect.bottom - chartRect.top + 8); // marge de 8px sous la HUD
  }

  ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.textBaseline = 'top';
  ctx.textAlign = 'left';

  const daySecFrom = Math.floor(visibleFrom / 86400) * 86400;
  const daySecTo   = Math.floor(visibleTo   / 86400) * 86400 + 86400;

  for (let day = daySecFrom; day <= daySecTo; day += 86400) {
    for (const s of SESSION_BANDS) {
      const sessionStart = day + s.startH * 3600;
      const sessionEnd   = Math.min(day + s.endH * 3600, lastBarTimeSec || (day + s.endH * 3600));
      if (sessionEnd <= sessionStart) continue;

      const x1 = tsApi.timeToCoordinate(sessionStart);
      const x2 = tsApi.timeToCoordinate(sessionEnd);
      if (!Number.isFinite(x1) || !Number.isFinite(x2)) continue;

      const left  = Math.max(0, Math.min(x1, x2));
      const right = Math.min(rightLimitX, Math.max(x1, x2));
      const w = right - left;
      if (w <= 1) continue;

      // Bande en fond
      ctx.fillStyle = s.fill;
      ctx.fillRect(left, 0, w, H);
      ctx.strokeStyle = s.stroke;
      ctx.lineWidth = 1;
      ctx.strokeRect(left + 0.5, 0.5, w - 1, H - 1);

      // Label en haut sous la HUD
      const label = s.name;
      const tw = ctx.measureText(label).width;
      const th = 16;
      const pad = 6;
      const lx = left + pad;
      const ly = topOffset;

      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(lx - 4, ly - 2, tw + 8, th + 2);
      ctx.fillStyle = 'rgba(17,24,39,0.95)';
      ctx.fillText(label, lx, ly);
      ctx.restore();
    }
  }

  ctx.restore();
}



  // === drawAOI (enhanced visibility) ===
  function drawAOI() {
    const ctx = overlay.getContext('2d');
    const W = overlay.width;

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    if (!candleSeries || !currentAOIs.length) return;

    const DPR = window.devicePixelRatio || 1;

    const fullWidthCss = W / DPR;
    const axisRightW   = getRightAxisWidthPx();
    const rightDrawX   = Math.max(0, fullWidthCss - axisRightW);

    // Stronger visuals (only style changes)
    const fill   = 'rgba(107,114,128,0.28)';  // was 0.18
    const border = 'rgba(107,114,128,0.70)';  // was 0.42
    const text   = 'rgba(17,24,39,0.95)';     // was 0.88

    const padRight = 10;  // was 8
    const padTextY = 0;

    ctx.save();
    ctx.scale(DPR, DPR);
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'right';

    for (const z of currentAOIs) {
      const lo = Math.min(+z.low, +z.high);
      const hi = Math.max(+z.low, +z.high);
      if (!Number.isFinite(lo) || !Number.isFinite(hi)) continue;

      const yLow  = candleSeries.priceToCoordinate(lo);
      const yHigh = candleSeries.priceToCoordinate(hi);
      if (!Number.isFinite(yLow) || !Number.isFinite(yHigh)) continue;

      const Y1 = Math.min(yLow, yHigh);
      const Y2 = Math.max(yLow, yHigh);
      const h  = Math.max(1, Y2 - Y1);

      ctx.fillStyle = fill;
      ctx.fillRect(0, Y1, fullWidthCss, h);

      ctx.strokeStyle = border;
      ctx.lineWidth = 2; // was 1
      ctx.strokeRect(0.5, Y1 + 0.5, fullWidthCss - 1, h - 1);

      const tf   = (z.tf || '').toString().trim().toUpperCase();
      const type = (z.type || '').toString().trim().toLowerCase();
      const label = [tf, type].filter(Boolean).join(' · ');
      if (!label) continue;

      const midY = (Y1 + Y2) / 2 + padTextY;
      const x = rightDrawX - padRight;

      const metrics = ctx.measureText(label);
      const tw = metrics.width || 0;
      const th = 16;
      const bx = x - tw - 6;
      const by = midY - th/2;

      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.90)'; // slightly stronger
      ctx.fillRect(bx, by, tw + 12, th);
      ctx.restore();

      ctx.fillStyle = text;
      ctx.fillText(label, x, midY);
    }

    ctx.restore();
  }

  // --- Draw orchestrator: clear -> sessions -> AOI
  function drawAll(){
    const ctx = overlay.getContext('2d');
    const W = overlay.width, H = overlay.height;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    drawSessions(); // sessions in background
    drawAOI();      // AOIs on top
  }

  function rafLoop(now){
    if (now - lastRAFTime < 200){
      drawAll();
      requestAnimationFrame(rafLoop);
    } else {
      rafActive = false;
    }
  }

  function scheduleDrawAOI(){ // keep name for compatibility
    drawAll();
    lastRAFTime = performance.now();
    if (!rafActive){
      rafActive = true;
      requestAnimationFrame(rafLoop);
    }
  }

  function fitOverlay(){
    const r = chartEl.getBoundingClientRect();
    overlay.width  = Math.floor(r.width  * devicePixelRatio);
    overlay.height = Math.floor(r.height * devicePixelRatio);
    overlay.style.width  = r.width + 'px';
    overlay.style.height = r.height + 'px';
    drawAll();
  }

  chart.timeScale().subscribeVisibleTimeRangeChange(()=>{ scheduleDrawAOI(); });
  new ResizeObserver(()=> fitOverlay()).observe(chartEl);
  ['wheel','mousemove','mousedown','mouseup'].forEach(evt=>{
    chartEl.addEventListener(evt, ()=>{
      lastRAFTime = performance.now();
      if (!rafActive){ rafActive=true; requestAnimationFrame(rafLoop); }
    }, {passive:true});
  });

  // --- series helpers ---
  function cleanupPriceLines(){
    if (lineUpper) { try { candleSeries.removePriceLine(lineUpper); } catch(e){} lineUpper = null; }
    if (lineLower) { try { candleSeries.removePriceLine(lineLower); } catch(e){} lineLower = null; }
  }

  function removeVolumeSeries(){
    if (volumeSeries){
      try { chart.removeSeries(volumeSeries); } catch(e){}
      volumeSeries = null;
    }
  }

  function ensureSeries(pair, tf){
    const key = `${pair}|${tf}`;
    if (key === currentKey && candleSeries) return false; // already ready

    // switching view -> recreate series
    if (candleSeries) { cleanupPriceLines(); chart.removeSeries(candleSeries); candleSeries = null; }
    if (emaSeries)    { chart.removeSeries(emaSeries);    emaSeries    = null; }
    removeVolumeSeries();
    currentAOIs = []; // AOI reset on view change
    lastBarTimeSec = null;

    // reset SL/TP on view change
    clearSL(); clearTP();

    const isJPY = pair && pair.endsWith('JPY');
    const precision = isJPY ? 3 : 5;
    const minMove   = isJPY ? 0.001 : 0.00001;
    currentMinMove  = minMove;

    candleSeries = chart.addSeries(CandlestickSeries, {
      upColor:'transparent', downColor:'#dc2626',
      borderUpColor:'#000000', borderDownColor:'#000000',
      wickUpColor:'#000000',  wickDownColor:'#000000',
      borderVisible:true,
      priceFormat:{ type:'price', precision, minMove },
    });
    candleSeries.priceScale().applyOptions({
      scaleMargins: { top: 0.05, bottom: 0.18 }
    });

    emaSeries = chart.addSeries(LineSeries, {
      priceFormat:{ type:'price', precision, minMove },
      lineWidth: 2,
      color: '#f59e0b',
      lastValueVisible: false,
      priceLineVisible: false,
      crosshairMarkerVisible: false,
    });

    currentKey = key;
    fitOverlay();
    return true;
  }

  // Create volume series lazily when data exists
  function ensureVolumeSeries(){
    if (volumeSeries) return;
    volumeSeries = chart.addSeries(HistogramSeries, {
      priceScaleId: '',
      priceFormat: { type: 'volume' },
      lastValueVisible: false,
      priceLineVisible: false,
    });
    volumeSeries.priceScale().applyOptions({
      scaleMargins: { top: 0.90, bottom: 0.00 }
    });
  }

  // Build volume points with colors from candle direction
  function buildVolumeData(candles, volumes){
    if (!Array.isArray(volumes) || !volumes.length) return [];
    const byTime = new Map();
    for (const c of (candles||[])) byTime.set(c.time, c);
    return volumes
      .filter(v => typeof v.time === 'number' && typeof v.value === 'number')
      .map(v => {
        const c = byTime.get(v.time);
        let color = '#dc2626';
        if (c){ color = (c.close >= c.open) ? '#16a34a' : '#dc2626'; }
        return { time: v.time, value: v.value, color };
      });
  }

  // --- structure lines (HH/HL or LH/LL) — NEUTRALIZED ---
  function applyStructureIfChanged(struct){
    // Remove any previously drawn structure lines and do nothing else.
    cleanupPriceLines();
    return;
  }

  // --- replaceAOIs (stable sort) ---
  function replaceAOIs(aois){
    const next = Array.isArray(aois)
      ? aois
          .filter(z => Number.isFinite(+z.low) && Number.isFinite(+z.high))
          .map(z => {
            const tf = String(z.tf || '').toUpperCase();
            const type = String(z.type || '').toLowerCase();
            const low  = +z.low;
            const high = +z.high;
            return {
              key: `${tf}|${low}|${high}|${type}`,
              tf, type, low, high
            };
          })
          .sort((a,b)=>{
            if (a.tf !== b.tf) return a.tf.localeCompare(b.tf);
            if (a.low !== b.low) return a.low - b.low;
            return a.high - b.high;
          })
      : [];

    let equal = next.length === currentAOIs.length;
    if (equal){
      for (let i=0;i<next.length;i++){
        if (!currentAOIs[i] || currentAOIs[i].key !== next[i].key) { equal = false; break; }
      }
    }
    if (!equal){
      currentAOIs = next;
      scheduleDrawAOI();
    }
  }

  // --- GLOBAL TREND banner ---
  function renderGlobalTrend(gt){
    if (!gtEl) return;
    const value = (gt && gt.value) ? String(gt.value).toUpperCase() : 'NONE';
    const basis = Array.isArray(gt?.basis) ? gt.basis : [];

    gtEl.classList.remove('gt-bull','gt-bear','gt-none');

    if (value === 'BULLISH') {
      gtEl.classList.add('gt','gt-bull');
      gtEl.innerHTML = `GLOBAL TREND: BULLISH <span class="basis">(${basis.join(' & ') || '—'})</span>`;
    } else if (value === 'BEARISH') {
      gtEl.classList.add('gt','gt-bear');
      gtEl.innerHTML = `GLOBAL TREND: BEARISH <span class="basis">(${basis.join(' & ') || '—'})</span>`;
    } else {
      gtEl.classList.add('gt','gt-none');
      gtEl.textContent = 'GLOBAL TREND: NO TREND';
    }
  }

  // --- WS ---
  function makeWsUrl(){
    const qs = new URLSearchParams(location.search);
    const override = qs.get('ws');
    if (override) return override;
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const host  = location.hostname || '127.0.0.1';
    const port  = qs.get('port') || '8765';
    return `${proto}//${host}:${port}`;
  }

  function connect(){
    const url = makeWsUrl();
    ws = new WebSocket(url);

    ws.onopen = () => {
      send({ role:'charts', schema:'1.0' });
      send({ action:'list' });
    };

    ws.onmessage = (ev) => {
      let msg; try { msg = JSON.parse(ev.data) } catch { return; }

      if (msg.type === 'hello') {
        // noop
      }
      else if (msg.type === 'meta') {
        buildUI(msg);
        if (!wantedTf && Array.isArray(msg.timeframes) && msg.timeframes.length) wantedTf = msg.timeframes[0];
        if (wantedPair && wantedTf) load(wantedPair, wantedTf);
      }
      else if (msg.type === 'candles') {
        if (msg.pair !== wantedPair || msg.tf !== wantedTf) return;

        const created = ensureSeries(msg.pair, msg.tf);
        const data    = Array.isArray(msg.candles) ? msg.candles : [];
        const emaData = Array.isArray(msg.ema50)   ? msg.ema50   : [];
        const volDataRaw = Array.isArray(msg.volumes) ? msg.volumes : [];

        if (created) {
          candleSeries.setData(data);
          if (emaSeries) emaSeries.setData(emaData.length ? emaData : []);

          if (volDataRaw.length){
            ensureVolumeSeries();
            volumeSeries.setData(buildVolumeData(data, volDataRaw));
          } else {
            removeVolumeSeries();
          }

          if (data.length >= 1) {
            lastClose = data[data.length - 1].close;
            if (!inpSL.value) inpSL.placeholder = String(lastClose);
            if (!inpTP.value) inpTP.placeholder = String(lastClose);
          }
          if (data.length >= 2) {
            const last = data[data.length - 1].time;
            const fromIndex = Math.max(0, data.length - 200);
            const from = data[fromIndex].time;
            chart.timeScale().setVisibleRange({ from, to: last });
            lastBarTimeSec = last;
          } else {
            lastBarTimeSec = data.length ? data[data.length - 1].time : null;
          }
        } else {
          if (data.length) {
            const prevLast = lastBarTimeSec;
            const newLast  = data[data.length - 1].time;

            if (prevLast == null) {
              candleSeries.setData(data);
              lastClose = data[data.length - 1].close;
            } else {
              let startIdx = data.findIndex(b => b.time >= prevLast);
              if (startIdx <= 0) {
                candleSeries.setData(data);
                lastClose = data[data.length - 1].close;
              } else {
                for (let i = startIdx; i < data.length; i++) {
                  candleSeries.update(data[i]);
                  lastClose = data[i].close;
                }
              }
            }
            lastBarTimeSec = newLast;
          }

          // EMA incremental
          if (emaSeries) {
            if (!emaData.length) {
              emaSeries.setData([]);
            } else {
              const prevLast = lastBarTimeSec;
              let startIdxE = emaData.findIndex(e => e.time >= prevLast);
              if (startIdxE <= 0) {
                emaSeries.setData(emaData);
              } else {
                for (let i = startIdxE; i < emaData.length; i++) {
                  emaSeries.update(emaData[i]);
                }
              }
            }
          }

          // VOLUME incremental
          if (volDataRaw.length){
            ensureVolumeSeries();
            const prevLast = lastBarTimeSec;
            const fullVolData = buildVolumeData(data, volDataRaw);
            let startIdxV = fullVolData.findIndex(v => v.time >= prevLast);
            if (startIdxV <= 0) {
              volumeSeries.setData(fullVolData);
            } else {
              for (let i = startIdxV; i < fullVolData.length; i++) {
                volumeSeries.update(fullVolData[i]);
              }
            }
          } else {
            removeVolumeSeries();
          }
        }

        applyStructureIfChanged(msg.structure);
        replaceAOIs(msg.aois);
        renderGlobalTrend(msg.global_trend);

        document.title = `${msg.pair} ${msg.tf} — FX Charts`;
      }
      else if (msg.type === 'error') {
        console.error('WS error from server:', msg.message);
      }
    };

    ws.onerror = () => { console.error('WebSocket error.'); };
    ws.onclose = () => {
      if (!reconnectTimer) {
        reconnectTimer = setTimeout(() => { reconnectTimer = null; connect(); }, 1200);
      }
    };
  }

  function send(obj){
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(obj));
    }
  }

  function load(pair, tf){
    if (!pair || !tf) return;
    wantedPair = pair;
    wantedTf   = tf;
    highlightUI(pair, tf);
    send({ action:'load', pair, tf });
  }

  // --- UI from meta ---
  function buildUI(meta){
    const pairs = Array.isArray(meta.pairs) ? [...meta.pairs].sort((a,b)=>a.localeCompare(b)) : [];
    pairSel.innerHTML = '';
    pairs.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p; opt.textContent = p;
      pairSel.appendChild(opt);
    });

    if (!wantedPair && pairs.length) wantedPair = pairs[0];
    if (wantedPair) {
      const opt = [...pairSel.options].find(o => o.value === wantedPair);
      if (opt) pairSel.value = wantedPair;
    }
    pairSel.onchange = (e) => {
      const sel = e.target.value;
      if (!sel) return;
      load(sel, wantedTf || (meta.timeframes?.[0] || '1D'));
    };

    const tfs = Array.isArray(meta.timeframes) ? meta.timeframes : [];
    tfsBox.innerHTML = '';
    tfs.forEach(tf => {
      const b = document.createElement('button');
      b.className = 'btn';
      b.textContent = tf;
      b.onclick = () => load(pairSel.value || pairs[0], tf);
      tfsBox.appendChild(b);
    });

    highlightUI(wantedPair || pairSel.value || pairs[0], wantedTf || tfs[0]);
  }

  function highlightUI(pair, tf){
    if (pair && pairSel.value !== pair) {
      const opt = [...pairSel.options].find(o => o.value === pair);
      if (opt) pairSel.value = pair;
    }
    [...tfsBox.querySelectorAll('.btn')].forEach(btn => {
      btn.classList.toggle('active', btn.textContent === tf);
    });
  }

  // boot
  connect();
  fitOverlay();
})();
</script>
</body>
</html>
